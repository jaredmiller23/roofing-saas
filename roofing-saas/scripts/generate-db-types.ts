/**
 * Generate Supabase Database types from PostgREST OpenAPI spec.
 *
 * Works with self-hosted Supabase behind Cloudflare/reverse proxy
 * where direct Postgres access isn't available.
 *
 * Usage: npx tsx scripts/generate-db-types.ts
 */

const API_URL = process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://api.jobclarity.io'
const SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || ''

interface SwaggerDefinition {
  type: string
  properties?: Record<string, SwaggerProperty>
  required?: string[]
  description?: string
}

interface SwaggerProperty {
  type?: string
  format?: string
  description?: string
  default?: unknown
  enum?: string[]
  maxLength?: number
  $ref?: string
  items?: { type?: string; $ref?: string }
}

interface SwaggerSpec {
  definitions: Record<string, SwaggerDefinition>
  paths: Record<string, Record<string, { parameters?: Array<{ name: string; in: string; type?: string; format?: string; description?: string; enum?: string[] }> }>>
}

function swaggerTypeToTS(prop: SwaggerProperty, required: boolean): string {
  const nullable = !required ? ' | null' : ''

  if (prop.$ref) {
    const refName = prop.$ref.replace('#/definitions/', '')
    return refName + nullable
  }

  switch (prop.format) {
    case 'uuid':
      return 'string' + nullable
    case 'timestamp with time zone':
    case 'timestamp without time zone':
    case 'date':
    case 'time with time zone':
    case 'time without time zone':
      return 'string' + nullable
    case 'bigint':
    case 'integer':
    case 'smallint':
    case 'double precision':
    case 'real':
    case 'numeric':
      return 'number' + nullable
    case 'boolean':
      return 'boolean' + nullable
    case 'json':
    case 'jsonb':
      return 'Json' + nullable
    case 'text[]':
    case 'character varying[]':
      return 'string[]' + nullable
    case 'uuid[]':
      return 'string[]' + nullable
    case 'integer[]':
    case 'bigint[]':
      return 'number[]' + nullable
    case 'bytea':
      return 'string' + nullable
    case 'inet':
    case 'cidr':
      return 'string' + nullable
    case 'tsvector':
      return 'string' + nullable
    case 'interval':
      return 'string' + nullable
    case 'point':
      return 'string' + nullable
    default:
      break
  }

  switch (prop.type) {
    case 'string':
      if (prop.enum) {
        return prop.enum.map(v => `'${v}'`).join(' | ') + nullable
      }
      return 'string' + nullable
    case 'integer':
    case 'number':
      return 'number' + nullable
    case 'boolean':
      return 'boolean' + nullable
    case 'array':
      if (prop.items) {
        const itemType = prop.items.type === 'string' ? 'string'
          : prop.items.type === 'integer' ? 'number'
          : prop.items.type === 'boolean' ? 'boolean'
          : 'unknown'
        return itemType + '[]' + nullable
      }
      return 'unknown[]' + nullable
    case 'object':
      return 'Json' + nullable
    default:
      return 'unknown' + nullable
  }
}

function hasDefault(prop: SwaggerProperty, description?: string): boolean {
  if (prop.default !== undefined) return true
  // UUID primary keys with gen_random_uuid() default
  if (prop.format === 'uuid' && description?.toLowerCase().includes('primary')) return true
  // Timestamps with now() default
  if (prop.format === 'timestamp with time zone' && prop.description?.includes('default')) return true
  return false
}

async function main() {
  if (!SERVICE_KEY) {
    console.error('SUPABASE_SERVICE_ROLE_KEY is required. Set it in .env.local or pass as env var.')
    process.exit(1)
  }

  console.log(`Fetching OpenAPI spec from ${API_URL}/rest/v1/...`)
  const res = await fetch(`${API_URL}/rest/v1/`, {
    headers: {
      'apikey': SERVICE_KEY,
      'Authorization': `Bearer ${SERVICE_KEY}`,
    },
  })

  if (!res.ok) {
    console.error(`Failed to fetch OpenAPI spec: ${res.status} ${res.statusText}`)
    process.exit(1)
  }

  const spec: SwaggerSpec = await res.json()
  const definitions = spec.definitions
  const tableNames = Object.keys(definitions).sort()

  console.log(`Found ${tableNames.length} table definitions.`)

  const lines: string[] = []
  lines.push('// Generated by scripts/generate-db-types.ts')
  lines.push('// DO NOT EDIT MANUALLY — regenerate with: npm run db:types')
  lines.push(`// Generated at: ${new Date().toISOString()}`)
  lines.push(`// Tables: ${tableNames.length}`)
  lines.push('')
  lines.push('export type Json =')
  lines.push('  | string')
  lines.push('  | number')
  lines.push('  | boolean')
  lines.push('  | null')
  lines.push('  | { [key: string]: Json | undefined }')
  lines.push('  | Json[]')
  lines.push('')
  lines.push('export type Database = {')
  lines.push('  public: {')
  lines.push('    Tables: {')

  for (const tableName of tableNames) {
    const def = definitions[tableName]
    if (!def.properties) continue

    const props = def.properties
    const required = new Set(def.required || [])
    const propNames = Object.keys(props).sort()

    lines.push(`      ${tableName}: {`)

    // Row type — all columns present, nullable ones have | null
    lines.push('        Row: {')
    for (const col of propNames) {
      const prop = props[col]
      const isRequired = required.has(col)
      const tsType = swaggerTypeToTS(prop, isRequired)
      lines.push(`          ${col}: ${tsType}`)
    }
    lines.push('        }')

    // Insert type — required columns are required, others optional
    lines.push('        Insert: {')
    for (const col of propNames) {
      const prop = props[col]
      const isRequired = required.has(col)
      const hasDef = hasDefault(prop, def.description)
      const tsType = swaggerTypeToTS(prop, isRequired)
      const optional = hasDef || !isRequired ? '?' : ''
      lines.push(`          ${col}${optional}: ${tsType}`)
    }
    lines.push('        }')

    // Update type — everything optional
    lines.push('        Update: {')
    for (const col of propNames) {
      const prop = props[col]
      const isRequired = required.has(col)
      const tsType = swaggerTypeToTS(prop, isRequired)
      lines.push(`          ${col}?: ${tsType}`)
    }
    lines.push('        }')

    lines.push('        Relationships: []')
    lines.push('      }')
  }

  lines.push('    }')
  lines.push('    Views: {')
  lines.push('      [_ in never]: never')
  lines.push('    }')
  lines.push('    Functions: {')

  // Extract functions from paths (RPC endpoints)
  const rpcPaths = Object.keys(spec.paths)
    .filter(p => p.startsWith('/rpc/'))
    .map(p => p.replace('/rpc/', ''))
    .sort()

  for (const fnName of rpcPaths) {
    const pathDef = spec.paths[`/rpc/${fnName}`]
    const postDef = pathDef?.post
    if (!postDef) continue

    const params = postDef.parameters?.filter(p => p.in === 'body') || []
    lines.push(`      ${fnName}: {`)
    lines.push('        Args: Record<string, unknown>')
    lines.push('        Returns: unknown')
    lines.push('      }')
  }

  lines.push('    }')
  lines.push('    Enums: {')
  lines.push('      [_ in never]: never')
  lines.push('    }')
  lines.push('    CompositeTypes: {')
  lines.push('      [_ in never]: never')
  lines.push('    }')
  lines.push('  }')
  lines.push('}')
  lines.push('')
  lines.push('type PublicSchema = Database[Extract<keyof Database, "public">]')
  lines.push('')
  lines.push('export type Tables<')
  lines.push('  PublicTableNameOrOptions extends')
  lines.push('    | keyof (PublicSchema["Tables"] & PublicSchema["Views"])')
  lines.push('    | { schema: keyof Database },')
  lines.push('  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }')
  lines.push('    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &')
  lines.push('        Database[PublicTableNameOrOptions["schema"]]["Views"])')
  lines.push('    : never = never,')
  lines.push('> = PublicTableNameOrOptions extends { schema: keyof Database }')
  lines.push('  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &')
  lines.push('      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {')
  lines.push('      Row: infer R')
  lines.push('    }')
  lines.push('    ? R')
  lines.push('    : never')
  lines.push('  : PublicTableNameOrOptions extends keyof (PublicSchema["Tables"] &')
  lines.push('        PublicSchema["Views"])')
  lines.push('    ? (PublicSchema["Tables"] &')
  lines.push('        PublicSchema["Views"])[PublicTableNameOrOptions] extends {')
  lines.push('        Row: infer R')
  lines.push('      }')
  lines.push('      ? R')
  lines.push('      : never')
  lines.push('    : never')
  lines.push('')
  lines.push('export type TablesInsert<')
  lines.push('  PublicTableNameOrOptions extends')
  lines.push('    | keyof PublicSchema["Tables"]')
  lines.push('    | { schema: keyof Database },')
  lines.push('  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }')
  lines.push('    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]')
  lines.push('    : never = never,')
  lines.push('> = PublicTableNameOrOptions extends { schema: keyof Database }')
  lines.push('  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {')
  lines.push('      Insert: infer I')
  lines.push('    }')
  lines.push('    ? I')
  lines.push('    : never')
  lines.push('  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]')
  lines.push('    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {')
  lines.push('        Insert: infer I')
  lines.push('      }')
  lines.push('      ? I')
  lines.push('      : never')
  lines.push('    : never')
  lines.push('')
  lines.push('export type TablesUpdate<')
  lines.push('  PublicTableNameOrOptions extends')
  lines.push('    | keyof PublicSchema["Tables"]')
  lines.push('    | { schema: keyof Database },')
  lines.push('  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }')
  lines.push('    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]')
  lines.push('    : never = never,')
  lines.push('> = PublicTableNameOrOptions extends { schema: keyof Database }')
  lines.push('  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {')
  lines.push('      Update: infer U')
  lines.push('    }')
  lines.push('    ? U')
  lines.push('    : never')
  lines.push('  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]')
  lines.push('    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {')
  lines.push('        Update: infer U')
  lines.push('      }')
  lines.push('      ? U')
  lines.push('      : never')
  lines.push('    : never')
  lines.push('')
  lines.push('export type Enums<')
  lines.push('  PublicEnumNameOrOptions extends')
  lines.push('    | keyof PublicSchema["Enums"]')
  lines.push('    | { schema: keyof Database },')
  lines.push('  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }')
  lines.push('    ? keyof Database[PublicEnumNameOrOptions["schema"]]["Enums"]')
  lines.push('    : never = never,')
  lines.push('> = PublicEnumNameOrOptions extends { schema: keyof Database }')
  lines.push('  ? Database[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]')
  lines.push('  : PublicEnumNameOrOptions extends keyof PublicSchema["Enums"]')
  lines.push('    ? PublicSchema["Enums"][PublicEnumNameOrOptions]')
  lines.push('    : never')
  lines.push('')

  const output = lines.join('\n')
  const fs = await import('fs')
  const path = await import('path')
  const outPath = path.join(process.cwd(), 'lib', 'types', 'database.types.ts')
  fs.writeFileSync(outPath, output, 'utf-8')

  console.log(`Generated ${outPath}`)
  console.log(`  Tables: ${tableNames.length}`)
  console.log(`  RPC Functions: ${rpcPaths.length}`)
}

main().catch(console.error)
